---
title: '**Spatial Economics -- Assignment 2**'
author: 
  - "Gustav Pirich (h11910449)"
  - "Peter Prlleshi ()"
  - "Filip Lukijanovic ()"
date: "April 2, 2024"
output: 
  pdf_document:
    toc: true
    includes:
      in_header: !expr file.path("~/Desktop/GITHUB/spatial_econ/helper/wraper_code.tex")
header-includes: 
  - \usepackage{tcolorbox}
  - \usepackage[default]{lato}
papersize: a4
geometry: margin = 2cm
urlcolor: DarkOrchid!65!black
---

```{r, setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
library(showtext)
showtext_auto()

library(sf)
library(tidyverse)
library(tmap)
library(viridis)
library(spdep)
library(igraph)
```

\vspace{2em}

\begin{tcolorbox}
\centering \itshape The code that was used in compiling the assignment is available on GitHub at \url{https://github.com/gustavpirich/spatial_econ/blob/main/02_assignment/02_assignmnet.Rmd}.
\end{tcolorbox}

\newpage

# Exercise A

```{r, echo = FALSE}
#reading in spatial dimension of productivity growth
load("~/Desktop/GITHUB/spatial_econ/data/02_assignmnet/Assignment___export/data1.rda")

#reading in Shapefile of EU-27
EU27 <- read_sf("~/Desktop/GITHUB/spatial_econ/data/02_assignmnet/Assignment___export/EU27.shp")

# we can also exclude all oversea territories
overseas <- c("FRY1", "FRY2", "FRY3", "FRY4", "FRY5", "FRZZ", 
              "PT20", "PT30", "PTZZ", 
              "ES70", "ESZZ", 
              "NO0B", "NOZZ")

east_germany_nuts2 <- c("DE40", "DE80", "DED3", "DED2", "DED1","DE42", "DE41", "DE30", "DED5", "DEE0", "DEG0", "DEE3", "DEE2", "DEE1")

EU27 <- EU27[! EU27$Id %in% overseas, ]
  
data1 <- data1[! data1$IDb %in% overseas, ]

data_1 <- data1 %>%
  filter(substr(IDb, 1, 2) %in% c("AT", "DE", "IT", "PT", "FR", "ES")) %>%
  select(IDb, pr80b, pr103b, lninv1b, lndens.empb) %>%
  rename("Id" = "IDb") %>%
  filter(!Id %in% east_germany_nuts2)

data_1$prod_growth <- (data_1$pr103b - data_1$pr80b) / data_1$pr80b

EU27 <- EU27 %>%
  filter(substr(Id, 1, 2) %in% c("AT", "DE", "IT", "PT", "FR", "ES")) %>%
  filter(!Id %in% east_germany_nuts2) %>%
  left_join(data_1, by = c("Id"))

```
## Calculate the growth rate of productivity from 1980 to 2013 and create a map that shows the productivity growth for each region. 

The map shows the productivity growth rates in the NUTS-2 regions for the selected countries. We can see that many regions especially in Germany, Austria, and France exhibited negative productivity growth over the selected time period. Notably, Portugal's productivity has been growing the fastest. We suspect that the negative growth rates can be explained by the fact that high-income countries had a high baseline productivity to being with, while Portugal had a low baseline productivity. This could be evidence of convergence among productivity differences across Europe.

```{r,echo = FALSE}
tm_shape(EU27) +
  tm_polygons("prod_growth",
          style = "cont") +
  tm_borders(col = "black", lwd = 2) +  # Adjust border color and line width
  tm_legend(position = c("left", "bottom"), legend.outside = TRUE) +
  tm_layout(frame = TRUE, bg.color = "lightblue") 
```

## Generate three different spatial weights matrixes using (i) a distance threshold, (ii) smooth distance-decay, and iii) a contiguity-based measure. 


### (i) Distance Threshold 
We first create a spatial weights matrix based on the distance threshold: 

```{r}
coords <- st_coordinates(st_centroid(EU27))

distw <- dnearneigh(coords, 0, 10, row.names=EU27$Id)
summary(distw)

#plot(coords)
#plot(distw, coords, add=TRUE, col="green", cex=0.1)

# Create a distance threshold spatial weights matrix
thresh_dist <- 10  # Threshold distance in km 
dist_w <- dnearneigh(coords, 0, thresh_dist)
dist_w_matrix <- nb2mat(dist_w, style="W", zero.policy=TRUE)
```

### (ii) Smooth-Distance Decay 
We now create a spatial weights matrix based on a smooth distance-decaqy
```{r}

# Calculate distances between all pairs
distances <- sp::spDists(coords, longlat=TRUE)
# Apply a distance decay function (inverse distance in this case)
decay_function <- function(d) exp(-0.01*d)
decay_weights_matrix <- decay_function(distances)

decay_weights_matrix <- decay_weights_matrix - diag(nrow(decay_weights_matrix))
```

### (iii) Contiguity-based measure 
```{r}
# Create a contiguity-based spatial weights matrix
contig_w <- poly2nb(EU27)
contig_w_matrix <- nb2mat(queen_weights, style="W", zero.policy=TRUE)

queen_weights <- poly2nb(EU27, queen = TRUE)

```

## Compare the matrices; use your knowledge of graph theory and linear algebra



## Plot the matrix
```{r, fig.width=5, fig.height=4}
image(dist_w_matrix, main="Distance Threshold Spatial Weights Matrix")

image(decay_weights_matrix, main="Smooth Distance-Decay Spatial Weights Matrix")

image(contig_w_matrix, main="Contiguity-Based Spatial Weights Matrix")
```

```{r}
# Convert to igraph objects for graph analysis
graph_dist <- graph_from_adjacency_matrix(dist_w_matrix, mode = "undirected", weighted = TRUE)
graph_decay <- graph_from_adjacency_matrix(as.matrix(decay_weights_matrix), mode = "undirected", weighted = TRUE)
graph_contig <- graph_from_adjacency_matrix(contig_w_matrix, mode = "undirected", weighted = TRUE)

# Function to summarize graph properties
summarize_graph <- function(g) {
  cat("Number of vertices:", vcount(g), "\n")
  cat("Number of edges:", ecount(g), "\n")
  cat("Average path length:", average.path.length(g, directed = FALSE), "\n")
  cat("Graph density:", edge_density(g), "\n")
  cat("Average degree:", mean(degree(g)), "\n")
  cat("Components:", components(g)$no, "\n")
}

# Analyze graph properties
cat("Distance Threshold Graph:\n")
summarize_graph(graph_dist)
cat("\nSmooth Distance-Decay Graph:\n")
summarize_graph(graph_decay)
cat("\nContiguity-Based Graph:\n")
summarize_graph(graph_contig)
```
## Compute a suitable measure of spatial autocorrelation for productivity growth using these matrices. Point out differences, if there are any. 

```{r}

# Convert the matrix to a listw object
your_weights <- mat2listw(dist_w_matrix)

your_weights <- mat2listw(decay_weights_matrix)

your_weights <- mat2listw(contig_w_matrix)

# Compute Global Moran's I
moran_result <- moran.test((EU27$prod_growth), listw = your_weights)

# Print the results
print(moran_result)

```

