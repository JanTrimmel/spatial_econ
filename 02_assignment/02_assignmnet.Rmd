---
title: '**Spatial Economics -- Assignment 2**'
author: 
  - "Gustav Pirich (h11910449)"
  - "Peter Prlleshi ()"
  - "Filip Lukijanovic ()"
date: "April 2, 2024"
output: 
  pdf_document:
    toc: true
    includes:
      in_header: !expr file.path("~/Desktop/GITHUB/spatial_econ/helper/wraper_code.tex")
header-includes: 
  - \usepackage{tcolorbox}
  - \usepackage[default]{lato}
papersize: a4
geometry: margin = 2cm
urlcolor: DarkOrchid!65!black
---

```{r, setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 80), tidy = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
library(showtext)
showtext_auto()

library(sf)
library(tidyverse)
library(tmap)
library(viridis)
library(spdep)
library(igraph)
library(spdep)
```

\vspace{2em}

\begin{tcolorbox}
\centering \itshape The code that was used in compiling the assignment is available on GitHub at \url{https://github.com/gustavpirich/spatial_econ/blob/main/02_assignment/02_assignmnet.Rmd}.
\end{tcolorbox}

\newpage

# Exercise A

```{r, echo = FALSE}
#reading in spatial dimension of productivity growth
load("~/Desktop/GITHUB/spatial_econ/data/02_assignmnet/Assignment___export/data1.rda")

#reading in Shapefile of EU-27
EU27 <- read_sf("~/Desktop/GITHUB/spatial_econ/data/02_assignmnet/Assignment___export/EU27.shp")

# we can also exclude all oversea territories
overseas <- c("FRY1", "FRY2", "FRY3", "FRY4", "FRY5", "FRZZ", 
              "PT20", "PT30", "PTZZ", 
              "ES70", "ESZZ", 
              "NO0B", "NOZZ")

east_germany_nuts2 <- c("DE40", "DE80", "DED3", "DED2", "DED1","DE42", "DE41", "DE30", "DED5", "DEE0", "DEG0", "DEE3", "DEE2", "DEE1")

EU27 <- EU27[! EU27$Id %in% overseas, ]
  
data1 <- data1[! data1$IDb %in% overseas, ]

data_1 <- data1 %>%
  filter(substr(IDb, 1, 2) %in% c("AT", "DE", "IT", "PT", "FR", "ES")) %>%
  select(IDb, pr80b, pr103b, lninv1b, lndens.empb) %>%
  rename("Id" = "IDb") %>%
  filter(!Id %in% east_germany_nuts2)

data_1$prod_growth <- (data_1$pr103b - data_1$pr80b) / data_1$pr80b

EU27 <- EU27 %>%
  filter(substr(Id, 1, 2) %in% c("AT", "DE", "IT", "PT", "FR", "ES")) %>%
  filter(!Id %in% east_germany_nuts2) %>%
  left_join(data_1, by = c("Id"))

```
## Calculate the growth rate of productivity from 1980 to 2013 and create a map that shows the productivity growth for each region. 

The map shows the productivity growth rates in the NUTS-2 regions for the selected countries. We can see that many regions especially in Germany, Austria, and France exhibited negative productivity growth over the selected time period. Notably, Portugal's productivity has been growing the fastest. We suspect that the negative growth rates can be explained by the fact that high-income countries had a high baseline productivity to being with, while Portugal had a low baseline productivity. This could be evidence of convergence among productivity differences across Europe.

```{r,echo = FALSE}
tm_shape(EU27) +
  tm_polygons("prod_growth", 
              title = "Productivity Growth",
              style = "cont", 
              lwd = 2) +
  tm_legend(position = c("left", "bottom"), legend.outside = TRUE) +
  tm_layout(frame = TRUE, bg.color = "lightblue") 
```

## Generate three different spatial weights matrixes using (i) a distance threshold, (ii) smooth distance-decay, and iii) a contiguity-based measure. 


### (i) Distance Threshold 
First, we create a spatial weights matrix based on the distance threshold criterion. Any region is being assigned a '1', if the center of any other region is less than 3 km away. Note that we have chosen this value so that every region has a neighbor. We use the nb2mat function from the 'spdep' package. We directly row-normalize the matrix.

```{r, echo = FALSE}
coords <- st_coordinates(st_centroid(EU27))

#checking the maximum distance as to include all observations which have a matrix   
nb1 <- knn2nb(knearneigh(coords, k = 1))

dist1 <- nbdists(nb1, coords)
summary(unlist(dist1))

distw <- dnearneigh(coords, 0, 3, row.names=EU27$Id)

#creating matrix based on distance threshold up to 3 kilometers
dist_w_matrix <- nb2mat(distw, style="W", zero.policy=TRUE)
```


### (ii) Smooth-Distance Decay 
Next, we create a spatial weights matrix based on a smooth distance-decay. We use the negative exponential decay function $w_{i, j} (d) = exp(-d)$. We calculate the weights for each neighboring region based on the k=2 nearest neighbors. We do not row-normalize the matrix.

```{r, echo = FALSE}
#nb <- poly2nb(EU27, queen = TRUE)

k2 <- knn2nb(knearneigh(coords, k = 1), row.names = EU27$Id)

dists <- nbdists(k2, coords)
ids <- lapply(dists, function(d){1/d})

decay_weights_matrix_list <- nb2listw(k2, glist = ids, style = "B", zero.policy = TRUE)

summary(decay_weights_matrix_list)
decay_weights_matrix <- listw2mat(decay_weights_matrix_list)
```

### (iii) Contiguity-based measure
Finally, we calculate a contiguity based measure, which we row normalize as well.
```{r}
# Create a contiguity-based spatial weights matrix
queen_weights <- poly2nb(EU27, queen = TRUE, row.names = EU27$Id)

contig_w_matrix <- nb2mat(queen_weights, style="W", zero.policy=TRUE)
```

## Compare the matrices; use your knowledge of graph theory and linear algebra



## Plot the matrix
```{r, fig.width=5, fig.height=4}
image(dist_w_matrix, main="Distance Threshold Spatial Weights Matrix")

image(decay_weights_matrix, main="Smooth Distance-Decay Spatial Weights Matrix")

image(contig_w_matrix, main="Contiguity-Based Spatial Weights Matrix")

lattice::levelplot(t(dist_w_matrix),
scales = list(y = list(at = c(10, 30, 50, 70),
                       labels = c(10, 20, 30, 40))))

lattice::levelplot(t(decay_weights_matrix),
scales = list(y = list(at = c(10, 30, 50, 70),
                       labels = c(10, 20, 30, 40))))

lattice::levelplot(t(contig_w_matrix),
scales = list(y = list(at = c(10, 30, 50, 70),
                       labels = c(10, 20, 30, 40))))
```
## Try to visualize the network they represent

Let us first visualize the distance based spatial matrix. 
```{r,echo = FALSE}
plot(EU27$geometry, border = "darkgrey")
plot(distw, coords, add=TRUE, col="lightblue", alpha = 0.5, cex=0.1)

plot(EU27$geometry, border = "darkgrey")
plot(decay_weights_matrix_list, coords, add=TRUE, col= "red", alpha = 0.5, cex=0.1)
```

```{r,echo = FALSE}
# Convert to igraph objects for graph analysis
graph_dist <- graph_from_adjacency_matrix(dist_w_matrix, mode = "undirected", weighted = TRUE)
graph_decay <- graph_from_adjacency_matrix((decay_weights_matrix), mode = "undirected")
graph_contig <- graph_from_adjacency_matrix(contig_w_matrix, mode = "undirected", weighted = TRUE)

# Function to summarize graph properties
summarize_graph <- function(g) {
  cat("Number of vertices:", vcount(g), "\n")
  cat("Number of edges:", ecount(g), "\n")
  cat("Average path length:", average.path.length(g, directed = FALSE), "\n")
  cat("Graph density:", edge_density(g), "\n")
  cat("Average degree:", mean(degree(g)), "\n")
  cat("Components:", components(g)$no, "\n")
}

# Analyze graph properties
cat("Distance Threshold Graph:\n")
summarize_graph(graph_dist)
cat("\nSmooth Distance-Decay Graph:\n")
summarize_graph(graph_decay)
cat("\nContiguity-Based Graph:\n")
summarize_graph(graph_contig)
```
## Compute a suitable measure of spatial autocorrelation for productivity growth using these matrices. Point out differences, if there are any. 

```{r,echo = FALSE}
# Convert the matrix to a listw object
l_dist_w_matrix <- mat2listw(dist_w_matrix, style = "B", zero.policy = TRUE)

l_decay_weights_matrix <- mat2listw(decay_weights_matrix, zero.policy = TRUE, style = "B")

l_contig_w_matrix <- mat2listw(contig_w_matrix, zero.policy = TRUE, style = "W")

# Compute Global Moran's I
moran_result_dist <- moran.test((EU27$prod_growth), listw = l_dist_w_matrix)

moran_result_decay <- moran.test((EU27$prod_growth), listw = l_decay_weights_matrix)

moran_result_contig <- moran.test((EU27$prod_growth), listw = l_contig_w_matrix)

# Print the results
summary(moran_result_dist, moran_result_decay, moran_result_contig)

```
## Estimate a linear regression model using OLS. 
```{r,echo = FALSE}
sm <- lm(prod_growth ~ pr80b + lninv1b + lndens.empb, EU27)

stargazer::stargazer(sm, output) %>%
  tidy() %>%
  kable(
    caption = "Coefficient-Level Estimates for a Model Fitted to Estimate Variation in Peer Ratings.",
    col.names = c("Predictor", "B", "SE", "t", "p"),
    digits = c(0, 2, 3, 2, 3)
  )

moran.plot(sm$residuals, l_dist_w_matrix)

moran.plot(sm$residuals, l_decay_weights_matrix)

moran.plot(sm$residuals, l_contig_w_matrix)
```

